function [traj, infStates] = hgf_binary3l_reward_social(r, p, varargin)
% Calculates the trajectories of the agent's representations under the HGF
%
% This function can be called in two ways:
% 
% (1) hgf_binary3l_reward_social(r, p)
%   
%     where r is the structure generated by fitModel and p is the parameter vector in native space;
%
% (2) hgf_binary3l_reward_social(r, ptrans, 'trans')
% 
%     where r is the structure generated by fitModel, ptrans is the parameter vector in
%     transformed space, and 'trans' is a flag indicating this.
%
% --------------------------------------------------------------------------------------------------
% Copyright (C) 2012-2013 Christoph Mathys, Andreea Diaconescu, TNU, UZH & ETHZ
%
% This file is part of the HGF toolbox, which is released under the terms of the GNU General Public
% Licence (GPL), version 3. You can redistribute it and/or modify it under the terms of the GPL
% (either version 3 or, at your option, any later version). For further details, see the file
% COPYING or <http://www.gnu.org/licenses/>.


% Transform paramaters back to their native space if needed
if ~isempty(varargin) && strcmp(varargin{1},'trans');
    p = hgf_binary3l_reward_social_transp(r, p);
end

% Number of levels
l = 3;

% Unpack parameters
mu2r_0 = p(1);
sa2r_0 = p(2);
mu3r_0 = p(3);
sa3r_0 = p(4);
ka_r    = p(5);
om_r    = p(6);
th_r    = p(7);

mu2a_0 = p(8);
sa2a_0 = p(9);
mu3a_0 = p(10);
sa3a_0 = p(11);
ka_a    = p(12);
om_a    = p(13);
th_a    = p(14);

% Add dummy "zeroth" trial
u_r = [0; r.u(:,1)];
u_a = [0; r.u(:,2)];

% Number of trials (including prior)
n_r = length(u_r);
n_a = length(u_a);

% Irregular trials for reward stimulus
try
    if r.c_prc.irregular_intervals
        if size(u_r,2) > 1
            t_r = [0; r.u_r(:,end)];
        else
            error('Input matrix must contain more than one column if irregular_intervals is set to true.');
        end
    else
        t_r = ones(n_r,1);
    end
catch
    if size(u_r,2) > 1
        t_r = [0; r.u_r(:,end)];
    else
        t_r = ones(n_r,1);
    end
end

% Irregular trials for advice
try
    if r.c_prc.irregular_intervals
        if size(u_a,2) > 1
            t_a = [0; r.u_a(:,end)];
        else
            error('Input matrix must contain more than one column if irregular_intervals is set to true.');
        end
    else
        t_a = ones(n_a,1);
    end
catch
    if size(u_a,2) > 1
        t_a = [0; r.u_a(:,end)];
    else
        t_a = ones(n_a,1);
    end
end

% Initialize updated quantities

% Representations
mu1_r = NaN(n_r,1);
mu2_r = NaN(n_r,1);
pi2_r = NaN(n_r,1);
mu3_r = NaN(n_r,1);
pi3_r = NaN(n_r,1);

mu1_a = NaN(n_a,1);
mu2_a = NaN(n_a,1);
pi2_a = NaN(n_a,1);
mu3_a = NaN(n_a,1);
pi3_a = NaN(n_a,1);


% Other quantities
mu1hat_r = NaN(n_r,1);
pi1hat_r = NaN(n_r,1);
pi2hat_r = NaN(n_r,1);
pi3hat_r = NaN(n_r,1);
w2_r     = NaN(n_r,1);
da1_r    = NaN(n_r,1);
da2_r    = NaN(n_r,1);

mu1hat_a = NaN(n_a,1);
pi1hat_a = NaN(n_a,1);
pi2hat_a = NaN(n_a,1);
pi3hat_a = NaN(n_a,1);
w2_a     = NaN(n_a,1);
da1_a    = NaN(n_a,1);
da2_a    = NaN(n_a,1);

% Representation priors
% Note: first entries of the other quantities remain
% NaN because they are undefined and are thrown away
% at the end; their presence simply leads to consistent
% trial indices.
mu1_r(1) = sgm(mu2r_0, 1);
mu2_r(1) = mu2r_0;
pi2_r(1) = 1/sa2r_0;
mu3_r(1) = mu3r_0;
pi3_r(1) = 1/sa3r_0;

mu1_a(1) = sgm(mu2a_0, 1);
mu2_a(1) = mu2a_0;
pi2_a(1) = 1/sa2a_0;
mu3_a(1) = mu3a_0;
pi3_a(1) = 1/sa3a_0;

% Pass through representation update loop
for k = 2:1:n_r
    if not(ismember(k-1, r.ign))
        
        %%%%%%%%%%%%%%%%%%%%%%
        % Effect of input u(k)
        %%%%%%%%%%%%%%%%%%%%%%

        % 1st level
        % ~~~~~~~~~
        % Prediction

        mu1hat_r(k) = sgm(mu2_r(k-1), 1);
        mu1hat_a(k) = sgm(mu2_a(k-1), 1);
        
        % Precision of prediction
        pi1hat_r(k) = 1/(mu1hat_r(k)*(1 -mu1hat_r(k)));
        pi1hat_a(k) = 1/(mu1hat_a(k)*(1 -mu1hat_a(k)));

        % Update
        mu1_r(k) = u_r(k);
        mu1_a(k) = u_a(k);

        % Prediction error
        da1_r(k) = mu1_r(k) -mu1hat_r(k);
        da1_a(k) = mu1_a(k) -mu1hat_a(k);

        % 2nd level
        % ~~~~~~~~~
        % Precision of prediction
        pi2hat_r(k) = 1/(1/pi2_r(k-1) +t_r(k) *exp(ka_r *mu3_r(k-1) +om_r));
        pi2hat_a(k) = 1/(1/pi2_a(k-1) +t_a(k) *exp(ka_a *mu3_a(k-1) +om_a));

        % Updates
        pi2_r(k) = pi2hat_r(k) +1/pi1hat_r(k);
        pi2_a(k) = pi2hat_a(k) +1/pi1hat_a(k);

        mu2_r(k) = mu2_r(k-1) +1/pi2_r(k) *da1_r(k);
        mu2_a(k) = mu2_a(k-1) +1/pi2_a(k) *da1_a(k);

        % Volatility prediction error
        da2_r(k) = (1/pi2_r(k) +(mu2_r(k) -mu2_r(k-1))^2) *pi2hat_r(k) -1;
        da2_a(k) = (1/pi2_a(k) +(mu2_a(k) -mu2_a(k-1))^2) *pi2hat_a(k) -1;


        % 3rd level
        % ~~~~~~~~~
        % Precision of prediction
        pi3hat_r(k) = 1/(1/pi3_r(k-1) +t_r(k) *th_r);
        pi3hat_a(k) = 1/(1/pi3_a(k-1) +t_a(k) *th_a);

        % Weighting factor
        w2_r(k) = t_r(k) *exp(ka_r *mu3_r(k-1) +om_r) *pi2hat_r(k);
        w2_a(k) = t_a(k) *exp(ka_a *mu3_a(k-1) +om_a) *pi2hat_a(k);

        % Updates
        pi3_r(k) = pi3hat_r(k) +1/2 *ka_r^2 *w2_r(k) *(w2_r(k) +(2 *w2_r(k) -1) *da2_r(k));
        pi3_a(k) = pi3hat_a(k) +1/2 *ka_a^2 *w2_a(k) *(w2_a(k) +(2 *w2_a(k) -1) *da2_a(k));

        if pi3_r(k) <= 0
            error('Error: negative pi3 in reward learning. Parameters are in a region where model assumptions are violated.');
        end
        
        if pi3_a(k) <= 0
            error('Error: negative pi3 in social learning. Parameters are in a region where model assumptions are violated.');
        end

        mu3_r(k) = mu3_r(k-1) +1/2 *1/pi3_r(k) *ka_r *w2_r(k) *da2_r(k);
        mu3_a(k) = mu3_a(k-1) +1/2 *1/pi3_a(k) *ka_a *w2_a(k) *da2_a(k);
    
    else
        mu1_r(k) = mu1_r(k-1); 
        mu2_r(k) = mu2_r(k-1);
        pi2_r(k) = pi2_r(k-1);
        mu3_r(k) = mu3_r(k-1);
        pi3_r(k) = pi3_r(k-1);

        mu1hat_r(k) = mu1hat_r(k-1);
        pi1hat_r(k) = pi1hat_r(k-1);
        pi2hat_r(k) = pi2hat_r(k-1);
        pi3hat_r(k) = pi3hat_r(k-1);
        w2_r(k)     = w2_r(k-1);
        da1_r(k)    = da1_r(k-1);
        da2_r(k)    = da2_r(k-1);
        
        mu1_a(k) = mu1_a(k-1); 
        mu2_a(k) = mu2_a(k-1);
        pi2_a(k) = pi2_a(k-1);
        mu3_a(k) = mu3_a(k-1);
        pi3_a(k) = pi3_a(k-1);

        mu1hat_a(k) = mu1hat_a(k-1);
        pi1hat_a(k) = pi1hat_a(k-1);
        pi2hat_a(k) = pi2hat_a(k-1);
        pi3hat_a(k) = pi3hat_a(k-1);
        w2_a(k)     = w2_a(k-1);
        da1_a(k)    = da1_a(k-1);
        da2_a(k)    = da2_a(k-1);
    end
end

% Get predictions on mu2 and mu3
mu2hat_r = mu2_r;
mu2hat_r(end) = [];
mu3hat_r = mu3_r;
mu3hat_r(end) = [];

mu2hat_a = mu2_a;
mu2hat_a(end) = [];
mu3hat_a = mu3_a;
mu3hat_a(end) = [];

% Remove representation priors
mu1_r(1)  = [];
mu2_r(1)  = [];
pi2_r(1)  = [];
mu3_r(1)  = [];
pi3_r(1)  = [];

mu1_a(1)  = [];
mu2_a(1)  = [];
pi2_a(1)  = [];
mu3_a(1)  = [];
pi3_a(1)  = [];

% Remove other dummy initial values
mu1hat_r(1) = [];
pi1hat_r(1) = [];
pi2hat_r(1) = [];
pi3hat_r(1) = [];
w2_r(1)     = [];
da1_r(1)    = [];
da2_r(1)    = [];

mu1hat_a(1) = [];
pi1hat_a(1) = [];
pi2hat_a(1) = [];
pi3hat_a(1) = [];
w2_a(1)     = [];
da1_a(1)    = [];
da2_a(1)    = [];


% Calculate variance at 1st level
sa1_r = mu1_r.*(1-mu1_r);
sa1_a = mu1_a.*(1-mu1_a);

% Create result data structure
traj = struct;

traj.mu_r = [mu1_r, mu2_r, mu3_r];
traj.sa_r = [sa1_r, 1./pi2_r, 1./pi3_r]; 

traj.mu_a = [mu1_a, mu2_a, mu3_a];
traj.sa_a = [sa1_a, 1./pi2_a, 1./pi3_a]; 

traj.muhat_r = [mu1hat_r, mu2hat_r, mu3hat_r];
traj.sahat_r = [1./pi1hat_r, 1./pi2hat_r, 1./pi3hat_r];

traj.muhat_a = [mu1hat_a, mu2hat_a, mu3hat_a];
traj.sahat_a = [1./pi1hat_a, 1./pi2hat_a, 1./pi3hat_a];

traj.w_r       = w2_r;
traj.da_r      = [da1_r, da2_r];

traj.w_a       = w2_a;
traj.da_a      = [da1_a, da2_a];

% Create matrices for use by observation model
infStates = NaN(n_r-1,l,4); % trials, levels, trajectories
infStates(:,:,1) = traj.muhat_r;
infStates(:,:,2) = traj.sahat_r;
infStates(:,:,3) = traj.muhat_a;
infStates(:,:,4) = traj.sahat_a;

return;
